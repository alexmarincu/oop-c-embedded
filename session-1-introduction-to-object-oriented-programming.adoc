= Introduction to Object-Oriented Programming in C for Embedded Systems

== Object-Oriented Programming (OOP)
Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects and their interactions. It encourages modular, reusable, and maintainable code.

== Advantages of OOP in Embedded Systems
* Code reusability: Reuse existing classes and libraries across projects
* Modularity: Divide complex systems into smaller, manageable objects
* Maintainability: Changes in one object have minimal impact on other objects
* Encapsulation: Protects data and implementation details from external access

== OOP in c?
OOP is a programming paradigm.

The concept of OOP emerged before the development of specific programming languages designed for it. OOP principles and ideas were initially conceived as a way to organize and structure software systems, and they later influenced the creation of programming languages that supported those concepts.

While the C programming language does not natively support OOP features, it is possible to apply some OOP concepts and principles in C code by following certain practices and techniques. 

== Encapsulation and Data Hiding
* Encapsulation: Bundling data and functions into a single unit (class)
* Data hiding: Restricting access to internal data of a class

=== Encapsulation
.Object.h
[source,c]
----
typedef struct {
    uint32_t attribute;
} Object;

void Object_init(Object * const self);
void Object_setAttribute(Object * const self, uint32_t const attribute);
uint32_t Object_getAttribute(Object * const self);
----

.Object.c
[source,c]
----
#include "Object.h"

void Object_init(Object * const self) {
    self->attribute = 0;
}

void Object_setAttribute(Object * const self, uint32_t const attribute) {
    self->attribute = attribute;
}
uint32_t Object_getAttribute(Object * const self) {
    return self->attribute;
}
----

.main.c
[source,c]
----
#include "Object.h"

int main() {
    Object obj;
    Object_init(&obj);                      // obj.init();
    Object_setAttribute(&obj, 5);           // obj.setAttribute(5);
    uint32_t a = Object_getAttribute(&obj); // obj.getAttribute();
    return 0;
}
----

=== Data hiding
.Object.h
[source,c]
----
typedef struct Object Object;

Object * Object_getInstance(void);
void Object_setAttribute(Object * const self, uint32_t const attribute);
uint32_t Object_getAttribute(Object * const self);
----

.Object.c
[source,c]
----
#include "Object.h"

struct Object {
    uint32_t attribute;
};

static void Object_init(Object * const self) {
    self->attribute = 0;
}

Object * Object_getInstance(void) {
    static Object self;
    static bool isInitialized = false;
    if (isInitialized == false) {
        Object_init(&self);
    }
    return &self;
}

void Object_setAttribute(Object * const self, uint32_t const attribute) {
    self->attribute = attribute;
}
uint32_t Object_getAttribute(Object * const self) {
    return self->attribute;
}
----

.main.c
[source,c]
----
#include "Object.h"

int main() {
    Object * obj = Object_getInstance();   // Object.getInstance();
    Object_setAttribute(obj, 5);           // obj.setAttribute(5);
    uint32_t a = Object_getAttribute(obj); // obj.getAttribute();
    return 0;
}
----

== Abstraction and Modularity
- Abstraction: Simplifying complex systems by representing essential features
- Modularity: Breaking down a system into independent and reusable components (classes)

.Timer.h
[source,c]
----
typedef struct {
    uint32_t startTimeInMillis;
    uint32_t delayInMillis;
} Timer;

Timer * Timer_init(Timer * const self);
void Timer_start(Timer * const self, uint32_t const delayInMillis);
void Timer_stop(Timer * const self);
bool Timer_isExpired(Timer const * const self);
----

.Timer.c
[source,c]
----
#include "Timer.h"
#include "TimeSource.h"

Timer * Timer_init(Timer * const self) {
    self->startTimeInMillis = 0;
    self->delayInMillis = 0;
    return self;
}

void Timer_start(Timer * const self, uint32_t const delayInMillis) {
    self->startTimeInMillis = TimeSource_getCurrentTimeInMillis();
    self->delayInMillis = delayInMillis;
}

void Timer_stop(Timer * const self) {
    Timer_init(self);
}

bool Timer_isExpired(Timer const * const self) {
    return (
        (self->startTimeInMillis != 0) &&
        ((TimeSource_getCurrentTimeInMillis() - self->startTimeInMillis) >= self->delayInMillis)
    );
}
----

.main.c
[source,c]
----
#include "Timer.h"

int main() {
    Timer * timer = Timer_init(&(Timer){0}); // new Timer();
    for (uint8_t index = 0; index < 5; index++) {
        Timer_start(timer, 1000);                     // timer.start(1000);
        while (Timer_isExpired(timer) == false) { ; } // timer.isExpired()
        printf("%d\n", index + 1);
    }
    return 0;
}
----

== Inheritance and Polymorphism
- Inheritance: Creating new classes (derived classes) based on existing classes (base classes)
- Polymorphism: Ability of objects to take on different forms or behaviors

.Shape.h
[source,c]
----
typedef struct Shape Shape;
typedef float (*Shape_area_function)(Shape const * const self);
struct Shape {
    uint32_t x;
    uint32_t y;
    Shape_area_function area;
};

Shape * Shape_init(Shape * const self, uint32_t const x, uint32_t const y);
float Shape_area(Shape const * const self);
----

.Shape.c
[source,c]
----
#include <assert.h>

static float Shape_area_notImplemented(Shape const * const self) {
    assert("Shape_area not implemented" && false);
    (void)self;
    return 0;
}

Shape * Shape_init(Shape * const self, uint32_t const x, uint32_t const y) {
    self->x = x;
    self->y = y;
    self->area = Shape_area_notImplemented;
    return self;
}

float Shape_area(Shape const * const self) {
    return self->area(self);
}
----

.Rectangle.h
[source,c]
----
#include "Shape.h"

typedef struct {
    Shape shape;
    uint32_t width;
    uint32_t height;
} Rectangle;

Rectangle * Rectangle_init(
    Rectangle * const self,
    uint32_t const x, uint32_t const y, uint32_t const width, uint32_t const height
);
uint32_t Rectangle_getWidth(Rectangle const * const self);
void Rectangle_setWidth(Rectangle * const self, uint32_t const width);
uint32_t Rectangle_getHeight(Rectangle const * const self);
void Rectangle_setHeight(Rectangle * const self, uint32_t const height);
float Rectangle_area(Rectangle const * const self);
----

.Rectangle.c
[source,c]
----
#include "Rectangle.h"

Rectangle * Rectangle_init(
    Rectangle * const self,
    uint32_t const x, uint32_t const y, uint32_t const width, uint32_t const height
) {
    Shape_init((Shape *)self, x, y);
    self->width = width;
    self->height = height;
    self->shape.area = (Shape_area_function)Rectangle_area;
    return self;
}

uint32_t Rectangle_getWidth(Rectangle const * const self) {
    return self->width;
}

void Rectangle_setWidth(Rectangle * const self, uint32_t const width) {
    self->width = width;
}

uint32_t Rectangle_getHeight(Rectangle const * const self) {
    return self->height;
}

void Rectangle_setHeight(Rectangle * const self, uint32_t const height) {
    self->height = height;
}

float Rectangle_area(Rectangle const * const self) {
    return self->width * self->height;
}
----

.Rectangle.c
[source,c]
----
include "Rectangle.h"

int main() {
    Rectangle * rectangle = Rectangle_init(&(Rectangle){0}, 0, 0, 5, 10); // new Rectangle(0, 0, 5, 10);
    Shape * shape = (Shape *)rectangle;
    float rectangleArea = Rectangle_area(rectangle); // rectangle.area();
    float shapeArea = Shape_area(shape);             // shape.area();
    return 0;
}
----

== Summary
- OOP organizes code around objects and their interactions
- OOP brings advantages like code reusability, modularity, maintainability, encapsulation
- C supports OOP techniques
- Encapsulation, abstraction, inheritance, and polymorphism are key OOP concepts

== Questions?
